import express from 'express';
import cors from 'cors';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';
import speakeasy from 'speakeasy';
import { z } from 'zod';
import rateLimit from 'express-rate-limit';

const prisma = new PrismaClient();
const app = express();
app.use(cors());
app.use(express.json());
const authLimiter = rateLimit({ windowMs: 10 * 60 * 1000, max: 50 });
app.use('/api/auth', authLimiter);
app.use('/api/2fa', authLimiter);

const JWT_SECRET = process.env.JWT_SECRET || 'dev_secret_change_me';
type JwtPayload = { sub: string };

function signToken(userId: string) { return jwt.sign({ sub: userId } as JwtPayload, JWT_SECRET, { expiresIn: '7d' }); }
function authMiddleware(req: any, res: any, next: any) {
  const header = req.headers.authorization || '';
  const token = header.startsWith('Bearer ')? header.slice(7): null;
  if (!token) return res.status(401).json({ error: 'Unauthorized' });
  try { const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload; (req as any).userId = decoded.sub; next(); } catch { return res.status(401).json({ error: 'Unauthorized' }); }
}
function requireRole(...roles: string[]) {
  return async (req: any, res: any, next: any) => {
    const userId = (req as any).userId; if (!userId) return res.status(401).json({ error: 'Unauthorized' });
    const user = await prisma.user.findUnique({ where: { id: userId } }); if (!user) return res.status(401).json({ error: 'Unauthorized' });
    if (!roles.includes(user.role)) return res.status(403).json({ error: 'Forbidden' }); next();
  };
}
async function writeAudit(companyId: string, actorId: string | null, action: string, details?: string, level: 'info'|'warning'|'error' = 'info') {
  try { await prisma.auditLog.create({ data: { companyId, actorId: actorId || undefined, action, details, level } }); } catch {}
}

app.get('/health', async (_req, res) => {
  let acme = await prisma.company.findUnique({ where: { name: 'Acme Corp' } }); if (!acme) acme = await prisma.company.create({ data: { name: 'Acme Corp' } });
  let adminCo = await prisma.company.findUnique({ where: { name: 'AdminCo' } }); if (!adminCo) adminCo = await prisma.company.create({ data: { name: 'AdminCo' } });

  const emp = await prisma.user.findUnique({ where: { username: 'aaron' } }); if (!emp) { const hash = await bcrypt.hash('password', 10); await prisma.user.create({ data: { username: 'aaron', email: 'aaron@company.com', passwordHash: hash, fullName: 'Aaron Employee', department: 'Operations', employeeId: 'EMP0001', companyId: acme.id } }); }
  const hr = await prisma.user.findUnique({ where: { username: 'hr1' } }); if (!hr) { const hash = await bcrypt.hash('password', 10); await prisma.user.create({ data: { username: 'hr1', email: 'hr1@company.com', passwordHash: hash, fullName: 'Harper HR', department: 'HR', employeeId: 'EMP9001', role: 'hr', companyId: acme.id } }); }
  const admin = await prisma.user.findUnique({ where: { username: 'admin' } }); if (!admin) { const hash = await bcrypt.hash('admin123', 10); await prisma.user.create({ data: { username: 'admin', email: 'admin@company.com', passwordHash: hash, fullName: 'Alex Admin', department: 'Admin', employeeId: 'EMP9999', role: 'admin', companyId: adminCo.id } }); }

  const demoUsers = [ { username: 'emma', email: 'emma@acme.com', fullName: 'Emma Stone', department: 'Finance' }, { username: 'liam', email: 'liam@acme.com', fullName: 'Liam Carter', department: 'Engineering' }, { username: 'olivia', email: 'olivia@acme.com', fullName: 'Olivia Brown', department: 'HR' } ];
  for (const du of demoUsers) { const exists = await prisma.user.findUnique({ where: { username: du.username } }); if (!exists) { const hash = await bcrypt.hash('password', 10); await prisma.user.create({ data: { username: du.username, email: du.email, passwordHash: hash, fullName: du.fullName, department: du.department, employeeId: `EMP${Math.floor(Math.random()*9000+1000)}`, role: 'employee', companyId: acme.id } }); } }
  const slabCount = await prisma.taxSlab.count({ where: { companyId: acme.id } }); if (slabCount === 0) { await prisma.taxSlab.createMany({ data: [ { companyId: acme.id, regime: 'old', minIncome: 0, maxIncome: 25000000, rateBps: 0 }, { companyId: acme.id, regime: 'old', minIncome: 25000000, maxIncome: 50000000, rateBps: 500 }, { companyId: acme.id, regime: 'old', minIncome: 50000000, maxIncome: 100000000, rateBps: 2000 }, { companyId: acme.id, regime: 'old', minIncome: 100000000, maxIncome: 0, rateBps: 3000 } ]}); }

  const acmeEmployees = await prisma.user.findMany({ where: { companyId: acme.id, role: 'employee' } }); const today = new Date();
  for (const e of acmeEmployees) {
    for (let i=1;i<=6;i++){ const end=new Date(today.getFullYear(), today.getMonth()-i+1, 0); const start=new Date(end.getFullYear(), end.getMonth(), 1); const exists=await prisma.payrollEntry.findFirst({ where:{ userId:e.id, companyId:acme.id, periodStart:start, periodEnd:end }}); if(!exists){ const base=250000; const bonus=i%3===0?50000:0; const ded=10000; const net=base+bonus-ded; await prisma.payrollEntry.create({ data:{ userId:e.id, companyId:acme.id, periodStart:start, periodEnd:end, baseSalary:base, bonus, deductions:ded, netPay:net }}); }}
    const hasReports=await prisma.report.count({ where:{ userId:e.id }}); if(hasReports===0){ await prisma.report.createMany({ data:[ { userId:e.id, companyId: acme.id, type:'payslip', period:'Mar 1 - Mar 15' }, { userId:e.id, companyId: acme.id, type:'payslip', period:'Feb 16 - Feb 28' }, { userId:e.id, companyId: acme.id, type:'yearend', period:`${today.getFullYear()-1}` } ]}); }
  }
  res.json({ ok: true });
});

app.post('/api/auth/login', async (req, res) => {
  const schema = z.object({ username: z.string(), password: z.string(), userAgent: z.string().optional() }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const { username, password, userAgent }=parsed.data; const user=await prisma.user.findUnique({ where:{ username } }); if(!user) return res.status(401).json({ error:'Invalid credentials' }); const ok=await bcrypt.compare(password, user.passwordHash); if(!ok) return res.status(401).json({ error:'Invalid credentials' }); if(user.twoFAEnabled){ return res.json({ twoFARequired:true }); } const session=await prisma.session.create({ data:{ userId:user.id, companyId:user.companyId, userAgent } }); const token=signToken(user.id); await prisma.user.update({ where:{ id:user.id }, data:{ lastLoginAt:new Date() } }); await writeAudit(user.companyId, user.id, 'login', 'User logged in'); return res.json({ token, sessionId:session.id, user:{ username:user.username, role:user.role, fullName:user.fullName } });
});

app.post('/api/auth/2fa', async (req, res) => {
  const schema=z.object({ username:z.string(), code:z.string().optional(), recoveryCode:z.string().optional(), userAgent:z.string().optional() }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const { username, code, recoveryCode, userAgent }=parsed.data; const user=await prisma.user.findUnique({ where:{ username } }); if(!user || !user.twoFAEnabled) return res.status(401).json({ error:'Unauthorized' }); let verified=false; if(recoveryCode){ const rec=await prisma.recoveryCode.findFirst({ where:{ userId:user.id, code:recoveryCode, usedAt:null } }); if(rec){ verified=true; await prisma.recoveryCode.update({ where:{ id:rec.id }, data:{ usedAt:new Date() } }); } } else if(code && user.twoFASecret){ verified = speakeasy.totp.verify({ secret:user.twoFASecret, encoding:'base32', token:code, window:1 }); } if(!verified) return res.status(401).json({ error:'Invalid 2FA verification' }); const session=await prisma.session.create({ data:{ userId:user.id, companyId:user.companyId, userAgent } }); const token=signToken(user.id); await prisma.user.update({ where:{ id:user.id }, data:{ lastLoginAt:new Date() } }); await writeAudit(user.companyId, user.id, '2fa_verify', '2FA verified'); return res.json({ token, sessionId:session.id, user:{ username:user.username, role:user.role, fullName:user.fullName } });
});

app.post('/api/2fa/setup', authMiddleware, async (req:any,res)=>{ const user=await prisma.user.findUnique({ where:{ id:req.userId } }); if(!user) return res.status(401).json({ error:'Unauthorized' }); const secret=speakeasy.generateSecret({ length:20, name:`PayrollPro:${user.username}`, issuer:'PayrollPro' }); return res.json({ base32: secret.base32, otpauthUrl: secret.otpauth_url }); });
app.post('/api/2fa/enable', authMiddleware, async (req:any,res)=>{ const schema=z.object({ base32:z.string(), code:z.string().length(6) }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const { base32, code }=parsed.data; const ok=speakeasy.totp.verify({ secret:base32, encoding:'base32', token:code, window:1 }); if(!ok) return res.status(400).json({ error:'Invalid code' }); const user=await prisma.user.update({ where:{ id:req.userId }, data:{ twoFAEnabled:true, twoFASecret:base32 } }); const codes=Array.from({ length:10 }).map(()=> randomCode()); await prisma.$transaction(codes.map(c=> prisma.recoveryCode.create({ data:{ userId:user.id, code:c } }))); await writeAudit(user.companyId, user.id, '2fa_enable', 'Enabled 2FA', 'warning'); res.json({ enabled:true, recoveryCodes:codes }); });
app.post('/api/2fa/disable', authMiddleware, async (req:any,res)=>{ const me=await prisma.user.findUnique({ where:{ id:req.userId } }); await prisma.user.update({ where:{ id:req.userId }, data:{ twoFAEnabled:false, twoFASecret:null } }); await prisma.recoveryCode.deleteMany({ where:{ userId:req.userId } }); if(me) await writeAudit(me.companyId, me.id, '2fa_disable', 'Disabled 2FA', 'warning'); res.json({ disabled:true }); });
app.post('/api/2fa/recovery/regenerate', authMiddleware, async (req:any,res)=>{ const me=await prisma.user.findUnique({ where:{ id:req.userId } }); await prisma.recoveryCode.deleteMany({ where:{ userId:req.userId } }); const codes=Array.from({ length:10 }).map(()=> randomCode()); await prisma.$transaction(codes.map(c=> prisma.recoveryCode.create({ data:{ userId:req.userId, code:c } }))); if(me) await writeAudit(me.companyId, me.id, '2fa_recovery_regen', 'Regenerated recovery codes'); res.json({ recoveryCodes:codes }); });

app.get('/api/sessions', authMiddleware, async (req:any,res)=>{ const user=await prisma.user.findUnique({ where:{ id:req.userId } }); const sessions=await prisma.session.findMany({ where:{ userId:req.userId, companyId:user?.companyId }, orderBy:{ lastActive:'desc' } }); res.json({ sessions }); });
app.delete('/api/sessions/:id', authMiddleware, async (req:any,res)=>{ const { id }=req.params; await prisma.session.deleteMany({ where:{ id, userId:req.userId } }); const me=await prisma.user.findUnique({ where:{ id:req.userId } }); if(me) await writeAudit(me.companyId, me.id, 'session_revoke', `Revoked ${id}`); res.json({ revoked:true }); });

app.get('/api/profile', authMiddleware, async (req:any,res)=>{ const u=await prisma.user.findUnique({ where:{ id:req.userId } }); if(!u) return res.status(404).json({ error:'Not found' }); res.json({ username:u.username, email:u.email, fullName:u.fullName, phone:u.phone, department:u.department, role:u.role, employeeId:u.employeeId, lastLoginAt:u.lastLoginAt, twoFAEnabled:u.twoFAEnabled }); });
app.put('/api/profile', authMiddleware, async (req:any,res)=>{ const schema=z.object({ fullName:z.string(), email:z.string().email(), phone:z.string().optional(), department:z.string().optional() }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const u=await prisma.user.update({ where:{ id:req.userId }, data:{ fullName:parsed.data.fullName, email:parsed.data.email, phone:parsed.data.phone, department:parsed.data.department } }); const me=await prisma.user.findUnique({ where:{ id:req.userId } }); if(me) await writeAudit(me.companyId, me.id, 'profile_update', 'Updated profile'); res.json({ ok:true, user:{ fullName:u.fullName, email:u.email, phone:u.phone, department:u.department } }); });

app.get('/api/reports/:id/pdf', authMiddleware, async (_req,res)=>{ res.setHeader('Content-Type','application/pdf'); res.setHeader('Content-Disposition','attachment; filename="report.pdf"'); const pdf=Buffer.from('%PDF-1.4\n1 0 obj\n<<>>\nendobj\ntrailer\n<<>>\n%%EOF'); res.end(pdf); });
app.get('/api/reports', authMiddleware, async (req:any,res)=>{ const me=await prisma.user.findUnique({ where:{ id:req.userId } }); if(!me) return res.status(401).json({ error:'Unauthorized' }); const reports=await prisma.report.findMany({ where:{ userId:me.id, companyId:me.companyId }, orderBy:{ createdAt:'desc' } }); res.json({ reports }); });

app.get('/api/hr/employees', authMiddleware, requireRole('hr','admin'), async (req:any,res)=>{ const me=await prisma.user.findUnique({ where:{ id:req.userId } }); const { companyId }=req.query as { companyId?: string }; const scopeCompanyId=me?.role==='admin' && companyId?companyId:me?.companyId; const employees=await prisma.user.findMany({ where:{ companyId:scopeCompanyId }, select:{ id:true, username:true, email:true, fullName:true, role:true, department:true, employeeId:true, lastLoginAt:true }, orderBy:{ username:'asc' } }); res.json({ employees }); });
app.post('/api/hr/employees', authMiddleware, requireRole('hr','admin'), async (req:any,res)=>{ const schema=z.object({ username:z.string(), email:z.string().email(), fullName:z.string(), department:z.string().optional(), role:z.enum(['employee','hr','admin']).default('employee'), password:z.string().min(6), companyId:z.string().optional() }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const { username, email, fullName, department, role, password, companyId }=parsed.data; const existing=await prisma.user.findFirst({ where:{ OR:[{ username },{ email }] } }); if(existing) return res.status(409).json({ error:'User exists' }); const hash=await bcrypt.hash(password,10); const me=await prisma.user.findUnique({ where:{ id:req.userId } }); const targetCompanyId=me?.role==='admin' && companyId?companyId:me!.companyId; const newEmp=await prisma.user.create({ data:{ username, email, fullName, department, role, passwordHash:hash, employeeId:`EMP${Math.floor(Math.random()*9000+1000)}`, companyId:targetCompanyId } }); if(me) await writeAudit(targetCompanyId!, me.id, 'employee_create', `Created ${username}`); res.status(201).json({ id:newEmp.id }); });
app.put('/api/hr/employees/:id/role', authMiddleware, requireRole('hr','admin'), async (req,res)=>{ const schema=z.object({ role:z.enum(['employee','hr','admin']) }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const { id }=req.params; const updated=await prisma.user.update({ where:{ id }, data:{ role:parsed.data.role } }); res.json({ ok:true, role:updated.role }); });

app.post('/api/hr/payroll', authMiddleware, requireRole('hr','admin'), async (req:any,res)=>{ const schema=z.object({ username:z.string(), periodStart:z.string(), periodEnd:z.string(), baseSalary:z.number().int().nonnegative(), bonus:z.number().int().nonnegative().default(0), deductions:z.number().int().nonnegative().default(0) }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const { username, periodStart, periodEnd, baseSalary, bonus, deductions }=parsed.data; const user=await prisma.user.findUnique({ where:{ username } }); const me=await prisma.user.findUnique({ where:{ id:req.userId } }); if(!user || user.companyId!==me?.companyId) return res.status(404).json({ error:'User not found' }); const netPay=baseSalary+bonus-deductions; const entry=await prisma.payrollEntry.create({ data:{ userId:user.id, companyId:me!.companyId, periodStart:new Date(periodStart), periodEnd:new Date(periodEnd), baseSalary, bonus, deductions, netPay } }); if(me) await writeAudit(me.companyId, me.id, 'payroll_create', `Payroll for ${username}`); res.status(201).json({ id:entry.id }); });
app.get('/api/hr/payroll', authMiddleware, requireRole('hr','admin'), async (req:any,res)=>{ const { username }=req.query as { username?: string }; const me=await prisma.user.findUnique({ where:{ id:req.userId } }); let where:any={ companyId:me?.companyId }; if(username){ const u=await prisma.user.findUnique({ where:{ username } }); if(!u) return res.json({ entries:[] }); where.userId=u.id; } const entries=await prisma.payrollEntry.findMany({ where, orderBy:{ createdAt:'desc' }, include:{ user:{ select:{ username:true, fullName:true, employeeId:true } } } }); res.json({ entries }); });
app.get('/api/payslips/:id/pdf', authMiddleware, async (req:any,res)=>{ const { id }=req.params; const me=await prisma.user.findUnique({ where:{ id:req.userId } }); const entry=await prisma.payrollEntry.findFirst({ where:{ id, companyId:me?.companyId }, include:{ user:true } }); if(!entry) return res.status(404).json({ error:'Not found' }); res.setHeader('Content-Type','application/pdf'); res.setHeader('Content-Disposition', `attachment; filename="payslip_${entry.user.username}_${entry.id}.pdf"`); const pdf=Buffer.from('%PDF-1.4\n1 0 obj\n<<>>\nendobj\ntrailer\n<<>>\n%%EOF'); res.end(pdf); });

function computeTDS(annualTaxableCents: number, slabs: { minIncome: number; maxIncome: number; rateBps: number }[]) { let tax=0; for(const s of slabs){ const lower=s.minIncome; const upper=isNaN(s.maxIncome as any)||s.maxIncome===0?Number.MAX_SAFE_INTEGER:s.maxIncome; if(annualTaxableCents>lower){ const taxableBand=Math.min(annualTaxableCents, upper)-lower; if(taxableBand>0) tax+=Math.floor((taxableBand*s.rateBps)/10000); } } return tax; }
app.get('/api/admin/tax/slabs', authMiddleware, requireRole('admin'), async (_req,res)=>{ const slabs=await prisma.taxSlab.findMany({ orderBy:[{ regime:'asc' },{ minIncome:'asc' }] }); res.json({ slabs }); });
app.post('/api/admin/tax/slabs', authMiddleware, requireRole('admin'), async (req:any,res)=>{ const schema=z.object({ companyId:z.string(), regime:z.enum(['old','new']), minIncome:z.number().int().nonnegative(), maxIncome:z.number().int().nonnegative(), rateBps:z.number().int().nonnegative() }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const slab=await prisma.taxSlab.create({ data:parsed.data }); res.status(201).json({ id:slab.id }); });
app.get('/api/tax/profile', authMiddleware, async (req:any,res)=>{ const user=await prisma.user.findUnique({ where:{ id:req.userId }, include:{ taxProfile:true } }); if(!user) return res.status(401).json({ error:'Unauthorized' }); if(!user.taxProfile){ const created=await prisma.employeeTaxProfile.create({ data:{ userId:user.id, companyId:user.companyId } }); return res.json({ profile:created }); } res.json({ profile:user.taxProfile }); });
app.put('/api/tax/profile', authMiddleware, async (req:any,res)=>{ const schema=z.object({ pan:z.string().optional(), regime:z.enum(['old','new']).optional(), section80C:z.number().int().nonnegative().optional(), hraExempt:z.number().int().nonnegative().optional(), ltaExempt:z.number().int().nonnegative().optional() }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const me=await prisma.user.findUnique({ where:{ id:req.userId } }); if(!me) return res.status(401).json({ error:'Unauthorized' }); const existing=await prisma.employeeTaxProfile.findUnique({ where:{ userId:me.id } }); const updated=existing? await prisma.employeeTaxProfile.update({ where:{ userId:me.id }, data:parsed.data }) : await prisma.employeeTaxProfile.create({ data:{ userId:me.id, companyId:me.companyId, ...(parsed.data as any) } }); res.json({ profile:updated }); });
app.get('/api/tax/forecast', authMiddleware, async (req:any,res)=>{ const me=await prisma.user.findUnique({ where:{ id:req.userId } }); if(!me) return res.status(401).json({ error:'Unauthorized' }); const profile=await prisma.employeeTaxProfile.findUnique({ where:{ userId:me.id } }); const slabs=await prisma.taxSlab.findMany({ where:{ companyId:me.companyId, regime:profile?.regime||'old' } }); const entries=await prisma.payrollEntry.findMany({ where:{ userId:me.id, companyId:me.companyId } }); const gross=entries.reduce((s,e)=> s+e.baseSalary+e.bonus,0); const deductions=entries.reduce((s,e)=> s+e.deductions,0) + (profile?.section80C||0) + (profile?.hraExempt||0) + (profile?.ltaExempt||0); const taxable=Math.max(0, gross-deductions); const annualTax=computeTDS(taxable, slabs); const projectedMonthlyTDS=Math.floor(annualTax/12); res.json({ gross, deductions, taxable, annualTax, projectedMonthlyTDS, regime: profile?.regime||'old' }); });
app.get('/api/tax/form16/:year/pdf', authMiddleware, async (req:any,res)=>{ const { year }=req.params; res.setHeader('Content-Type','application/pdf'); res.setHeader('Content-Disposition', `attachment; filename="Form16_${year}.pdf"`); const pdf=Buffer.from('%PDF-1.4\n1 0 obj\n<<>>\nendobj\ntrailer\n<<>>\n%%EOF'); res.end(pdf); });
app.post('/api/hr/tax/preview', authMiddleware, requireRole('hr','admin'), async (req:any,res)=>{ const schema=z.object({ username:z.string(), baseSalary:z.number().int().nonnegative(), bonus:z.number().int().nonnegative().default(0), deductions:z.number().int().nonnegative().default(0) }); const parsed=schema.safeParse(req.body); if(!parsed.success) return res.status(400).json({ error:'Invalid payload' }); const { username, baseSalary, bonus, deductions }=parsed.data; const user=await prisma.user.findUnique({ where:{ username } }); const me=await prisma.user.findUnique({ where:{ id:req.userId } }); if(!user || user.companyId!==me?.companyId) return res.status(404).json({ error:'User not found' }); const profile=await prisma.employeeTaxProfile.findUnique({ where:{ userId:user.id } }); const regime=profile?.regime||'old'; const slabs=await prisma.taxSlab.findMany({ where:{ companyId:user.companyId, regime } }); const annualGross=12*(baseSalary+bonus); const annualDeductions=12*deductions + (profile?.section80C||0) + (profile?.hraExempt||0) + (profile?.ltaExempt||0); const taxable=Math.max(0, annualGross-annualDeductions); const annualTax=computeTDS(taxable, slabs); const monthlyTDS=Math.floor(annualTax/12); res.json({ monthlyTDS, regime }); });

function randomCode(){ const alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'; const rand=Array.from({ length:4 },()=> alphabet[Math.floor(Math.random()*alphabet.length)]).join(''); const rand2=Array.from({ length:4 },()=> alphabet[Math.floor(Math.random()*alphabet.length)]).join(''); return `${rand}-${rand2}`; }
const port=process.env.PORT||4000; app.listen(port, ()=>{ console.log(`API listening on http://localhost:${port}`); });

app.get('/api/admin/audit-logs', authMiddleware, requireRole('admin'), async (req: any, res) => {
  const { level, action, q, take, skip } = req.query as { level?: string, action?: string, q?: string, take?: string, skip?: string };
  const where: any = {};
  if (level) where.level = level;
  if (action) where.action = { contains: action, mode: 'insensitive' };
  if (q) where.details = { contains: q, mode: 'insensitive' };
  const limit = Math.min(parseInt(take || '50', 10) || 50, 200);
  const offset = parseInt(skip || '0', 10) || 0;
  const logs = await prisma.auditLog.findMany({ where, orderBy: { createdAt: 'desc' }, take: limit, skip: offset });
  res.json({ logs });
});

